## linux shell script

### shell 和 CLI

shell 不是操作系统内核的一部分，而是构建在内核上的一个应用程序，是人与系统交互的介质。

在早期 Linux 系统中，与 Unix 系统进行交互的唯一方式就是借助 shell 所提供的文本命令行（command line interface， CLI）来操作应用程序，管理文件等。

早期亚终端是利用串行电缆链接到 Unix 系统上的一台显示其和键盘，该亚终端是该 Unix 的控制台。现在 Linux 进入 CLI 的方式，可以直接退出图形化模式，进入文本模式，这种模式称作 Linux 控制台，它仿真早期的亚终端。

现代 Linux 启动之后，会自动创建出一些（5-6个）虚拟控制台，其是运行在内存中的终端会话，不要在计算机上硬件连接多个真实的亚终端，当你在图形化 terminal 新建窗口时候，出现的 ttys00x 其实就是连接到已经运行的虚拟控制台-亚终端。

![Image](/blog-2020/images/lss_ttys.jpg)

shell 包含一组内部命令（builtin cmd），用这些命令可以完成诸如设备操作，文件操作，启动停止程序。你也可以将多个 shell 命令放到文件中作为程序串来执行，这些文件被称为 shell 脚本。

在 Linux 系统上，通常有好几种 shell 可用，不同的 shell 有不同的特征。不同 shell 的脚本之间不一定能够移植使用，由于几乎所有 Linux 发行版（除了 Ubuntu）都会以 bash shell 作为默认新 shell，所以写 bash shell 脚本会更加通用和朴素。当前有更加强大的 zsh 弥补了 bash 的不足，并且完全兼容 bash 语法。在日常开发使用 zsh 工具会更加强力和顺手。
  
### 基本 bash shell

本节会介绍一些除了日常 Linux 操作的命令之外的一些容易忽视但是还比较使用的点：

- ls 命令的简单匹配过滤，在 pattern 中使用 ？ 来代表一个字符，× 来代表 0 个或者多个字符： ls -l prefix*，此外使用 \[xx], \[!xx] 来指定字符组或者排除字符组：ls -l ca\[tp]
- ls -i 可以查看文件的 inode 号，硬链接的两个文件具有相同的 inode，软链接的两个文件，则有不同的 inode。
- less 是 more 翻页显示升级版，可以识别键盘上下左右键位和提供了一些高级搜索的功能，在查看很大的 tidb log 的时候比较有用。
- head 和 tail 可以专门查看文件的头部和尾部的指定的行数，可以使用 -n 显示指定的行数。
- ps 显示某个时刻的进程信息，top 可以实时显示进程信息。
- 信号是 Linux 进程通信的一个简约手段，对特定的信号规定其代表的特定意义，来达到默认的规约。
    - 1  HUP 挂起
    - 2  INT 中断
    - 3  QUIT 结束运行
    - 9  KILL 无条件截止
    - 11 SEGV 段错误
    - 15 TERM 尽可能终止
    - 17 STOP 无条件停止，但是不终止
    - 18 TSTP 停止或暂停，但继续在后台运行
    - 19 CONT 在 STOP 或 TSTP 之后恢复运行
- kill 命令会默认向程序发 term 命令，kill 也可以直接指定信号类型，-s 参数可以指定信号类型或者信号号码，也支持直接使用类似 -9/-kill 来只指定信号。
- df 显示总体磁盘使用情况，du 可以显示具体的文件夹磁盘使用情况。
- grep 的反向搜索功能，grep -v \[pattern] file, pattern 可以使用正则。
- tar & zip 归档和压缩实际上是两个命令，但很多情况我们会看到 xx.tar.zip 结尾的文件，tar 命令的 -z 参数可以将输出重定向给 zip 命令来压缩和解压，这样可以避免显示操作 zip 命令。其也是 Linux 中分发源程序的普遍方法。

### 理解 shell
运行的 shell 是一个进程，在显式运行 bash 命令之后，就会开启一个新的 shell 进程，这种关系叫做 shell 的父子关系，如此称为显式的开启子 shell。在命令列表（用`()`包括一连串命令，`;`分隔）执行时也可以隐式的开启子进程来运行命令。此外后台模式（使用 & 后缀）运行的作业也是开子进程来运行

内建命令和外部命令的区别是前者不需要使用子 shell 来执行，因为它们已经和 shell 编译成了一体，使用 type 命令可以区分命令是内建的还是外部的，如： type cd。

环境变量基本都是大写，global 变量对于本 shell 及子 shell 都是可见的（全局变量的传递性），local 变量只对创建它们的 shell 可见。这在执行 shell 脚本时候传递参数时候会比较有用。使用 env / printenv 显示当前 shell 可见的全局变量

Linux 并没有特殊的命令来只看局部变量，但是可以 set 命令来查看所有的变量（包括全局的，局部的和用户自定义的）。定义用户自定义变量时，需要注意等号两端不能有空格，对于有空格的值必须使用单引号来括起来。如：a='aaa', 如果想让其变为全局变量可以 export a（最好是定义成 A），该变量可以传递到子 shell。

### 构建 shell 脚本

  



