## linux shell script

### shell 和 CLI

shell 不是操作系统内核的一部分，而是构建在内核上的一个应用程序，是人与系统交互的介质。

在早期 Linux 系统中，与 Unix 系统进行交互的唯一方式就是借助 shell 所提供的文本命令行（command line interface， CLI）来操作应用程序，管理文件等。

早期亚终端是利用串行电缆链接到 Unix 系统上的一台显示器和键盘，该亚终端是该 Unix 的控制台。现在 Linux 进入 CLI 的方式，可以直接退出图形化模式，进入文本模式，这种模式称作 Linux 控制台，它仿真早期的亚终端。

现代 Linux 启动之后，会自动创建出一些（5-6个）虚拟控制台，其是运行在内存中的终端会话，不需要在计算机上硬件连接多个真实的亚终端，当你在图形化 terminal 新建窗口时候，出现的 ttys00x 其实就是连接到已经运行的虚拟控制台-亚终端。

![Image](/blog-2020/images/lss_ttys.jpg)

shell 包含一组内部命令（builtin cmd），用这些命令可以完成诸如设备操作，文件操作，启动停止程序。你也可以将多个 shell 命令放到文件中作为程序串来执行，这些文件被称为 shell 脚本。

在 Linux 系统上，通常有好几种 shell 可用，不同的 shell 有不同的特征。不同 shell 的脚本之间不一定能够移植使用，由于几乎所有 Linux 发行版（除了 Ubuntu）都会以 bash shell 作为默认新 shell，所以写 bash shell 脚本会更加通用和朴素。当前有更加强大的 zsh 弥补了 bash 的不足，并且完全兼容 bash 语法。在日常开发使用 zsh 工具会更加强力和顺手。
  
### 基本 bash shell

本节会介绍一些除了日常 Linux 操作的命令之外的一些容易忽视但是还比较使用的点：

- ls 命令的简单匹配过滤，在 pattern 中使用 ？ 来代表一个字符，× 来代表 0 个或者多个字符： ls -l prefix*，此外使用 \[xx], \[!xx] 来指定字符组或者排除字符组：ls -l ca\[tp]
- ls -i 可以查看文件的 inode 号，硬链接的两个文件具有相同的 inode，软链接的两个文件，则有不同的 inode。
- less 是 more 翻页显示升级版，可以识别键盘上下左右键位和提供了一些高级搜索的功能，在查看很大的 tidb log 的时候比较有用。
- head 和 tail 可以专门查看文件的头部和尾部的指定的行数，可以使用 -n 显示指定的行数。
- ps 显示某个时刻的进程信息，top 可以实时显示进程信息。
- 信号是 Linux 进程通信的一个简约手段，对特定的信号规定其代表的特定意义，来达到默认的规约。
    - 1  HUP 挂起
    - 2  INT 中断
    - 3  QUIT 结束运行
    - 9  KILL 无条件截止
    - 11 SEGV 段错误
    - 15 TERM 尽可能终止
    - 17 STOP 无条件停止，但是不终止
    - 18 TSTP 停止或暂停，但继续在后台运行
    - 19 CONT 在 STOP 或 TSTP 之后恢复运行
- kill 命令会默认向程序发 term 命令，kill 也可以直接指定信号类型，-s 参数可以指定信号类型或者信号号码，也支持直接使用类似 -9/-kill 来只指定信号。
- df 显示总体磁盘使用情况，du 可以显示具体的文件夹磁盘使用情况。
- grep 的反向搜索功能，grep -v \[pattern] file, pattern 可以使用正则。
- tar & zip 归档和压缩实际上是两个命令，但很多情况我们会看到 xx.tar.zip 结尾的文件，tar 命令的 -z 参数可以将输出重定向给 zip 命令来压缩和解压，这样可以避免显示操作 zip 命令。其也是 Linux 中分发源程序的普遍方法。

### 理解 shell
运行的 shell 是一个进程，在显式运行 bash 命令之后，就会开启一个新的 shell 进程，这种关系叫做 shell 的父子关系，如此称为显式的开启子 shell。在命令列表（用`()`包括一连串命令，`;`分隔）执行时也可以隐式的开启子进程来运行命令。此外后台模式（使用 & 后缀）运行的作业也是开子进程来运行。

内建命令和外部命令的区别是前者不需要使用子 shell 来执行，因为它们已经和 shell 编译成了一体，使用 type 命令可以区分命令是内建的还是外部的，如： type cd。

环境变量基本都是大写，global 变量对于本 shell 及子 shell 都是可见的（全局变量的传递性），local 变量只对创建它们的 shell 可见。这在执行 shell 脚本时候传递参数时候会比较有用。使用 env / printenv 显示当前 shell 可见的全局变量。

Linux 并没有特殊的命令来只看局部变量，但是可以 set 命令来查看所有的变量（包括全局的，局部的和用户自定义的）。定义用户自定义变量时，需要注意等号两端不能有空格，对于有空格的值必须使用单引号来括起来。如：a='aaa', 如果想让其变为全局变量可以 export a（最好是定义成 A），该变量可以传递到子 shell。

### 构建 shell 脚本
创建 shell 脚本时，必须在文件的第一行指定要使用的 shell 类型，并以注释符号（#）开头。
```shell script
#!/bin/bash
```
shell 脚本使用的命令必须是内建命令，或者是外部命令，这意味着你的二进制文件所在的 path 必须要在全局变量 $PATH 中。

shell 脚本中使用全局变量，可以使用 $var 或者 ${var} 来 eval 变量的值。这种 eval 效果即使在字符串中，也能正确的 eval，而不是识别为字符串的一部分。
```shell script
echo $HOME, ${HOME}
ehco "hahah $HOME"
``` 

命令替换应该是 shell 脚本中最为重要的一种使用方法了，其本意为从命令输出中提取信息，并将其赋值给变量。这个特性在处理流式数据时候尤其方便。有两种方法可以将命令的输出赋值给变量：
- 反引号 (`)
- $() 注意这个与 eval 变量的 ${} 的区别
```shell script
a=`ls`
a=$(ls)
echo $a, ${a} # a 是变量，存储的是 ls 的结果。
```

重定向可以将命令输出定向输出到文件中（或者从文件读），管道可以将命令输出重定向到另外一个命令。
```shell script
ls > ls_output
ls | cat
```

表达式计算, 由于 expr 表达式比较受限这里不予介绍，这里介绍方括号数学表达式计算: 
```shell script
a=$[1+5]  # 将数学表达计算结果 eval 出来赋值给 a
b=$[$a+5] # 表示式中需要先 eval 一下 a 变量的具体值

# 方括号值能支持整数运算，实数运算需要 bc
# zsh 下提供实数计算的支持，可以使用双 (()) 或者 let 命令
```

命令退出码，$?保存了上一个命令的退出状态码，成功退出为 0, 错误就是一个整数（一般在1-255）
```shell script
# finish script successfully (对于 shell 脚本来说自身也是一个程序，需要有一定的退出码供外部识别)
exit 0
```

结构化操作命令，是 shell 脚本逻辑处理的骨架，if 后面的对象的逻辑是靠其对出码来识别的，0 則继续，不然 else（这里区别其他编程语言）
```shell script
if command
then
    commands
else
    commands # 另外还有 elif
fi
```

test 命令：由于 if 命令只能是被 0-255 的状态退出码，退出状态码之外的条件需要使用 test 命令或者方括号 [] 来检测




在编写完成 shell.sh 之后，需要给予文件可执行权限，才能被正确执行（chmod u+x shell.sh）。

